"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Dw = function (c) {
  var e = {
    LIBRARY: "p5.EasyCam",
    VERSION: "1.0.9",
    AUTHOR: "Thomas Diewald",
    SOURCE: "https://github.com/diwi/p5.EasyCam",
    toString: function toString() {
      return this.LIBRARY + " v" + this.VERSION + " by " + this.AUTHOR + " (" + this.SOURCE + ")";
    }
  };

  var f = /*#__PURE__*/function () {
    function f(n, o) {
      _classCallCheck(this, f);

      if (!(n instanceof p5.RendererGL)) return void console.log("renderer needs to be an instance of p5.RendererGL");
      o = o || {}, void 0 === o.distance && (o.distance = 500), void 0 === o.center && (o.center = [0, 0, 0]), void 0 === o.rotation && (o.rotation = k.identity()), void 0 === o.viewport && (o.viewport = [0, 0, n.width, n.height]), this.INFO = e, this.setCanvas(n);
      var p = this;
      this.cam = p, this.LOOK = [0, 0, 1], this.UP = [0, 1, 0], this.AXIS = new function () {
        this.YAW = 1, this.PITCH = 2, this.ROLL = 4, this.ALL = this.YAW | this.PITCH | this.ROLL;
      }(), this.SHIFT_CONSTRAINT = 0, this.FIXED_CONSTRAINT = 0, this.DRAG_CONSTRAINT = 0, this.scale_rotation = 1e-3, this.scale_pan = 2e-4, this.scale_zoom = 1e-3, this.scale_zoomwheel = 20, this.distance_min_limit = 0.01, this.distance_min = 1, this.distance_max = Number.MAX_VALUE, this.state = {
        distance: o.distance,
        center: o.center.slice(),
        rotation: o.rotation.slice(),
        copy: function copy(q) {
          return q = q || {}, q.distance = this.distance, q.center = this.center.slice(), q.rotation = this.rotation.slice(), q;
        }
      }, this.state_reset = this.state.copy(), this.state_pushed = this.state.copy(), this.viewport = o.viewport.slice(), this.mouse = {
        cam: p,
        curr: [0, 0, 0],
        prev: [0, 0, 0],
        dist: [0, 0, 0],
        mwheel: 0,
        isPressed: !1,
        istouchdown: !1,
        ismousedown: !1,
        BUTTON: {
          LMB: 1,
          MMB: 2,
          RMB: 4
        },
        button: 0,
        mouseDragLeft: p.mouseDragRotate.bind(p),
        mouseDragCenter: p.mouseDragPan.bind(p),
        mouseDragRight: p.mouseDragZoom.bind(p),
        mouseWheelAction: p.mouseWheelZoom.bind(p),
        touchmoveSingle: p.mouseDragRotate.bind(p),
        touchmoveMulti: function touchmoveMulti() {
          p.mouseDragPan(), p.mouseDragZoom();
        },
        insideViewport: function insideViewport(q, r) {
          var u = p.viewport[0],
              v = u + p.viewport[2],
              A = p.viewport[1],
              B = A + p.viewport[3];
          return q > u && q < v && r > A && r < B;
        },
        solveConstraint: function solveConstraint() {
          var q = this.dist[0],
              r = this.dist[1];
          this.shiftKey && !p.SHIFT_CONSTRAINT && 1 < Math.abs(q - r) && (p.SHIFT_CONSTRAINT = Math.abs(q) > Math.abs(r) ? p.AXIS.YAW : p.AXIS.PITCH), p.DRAG_CONSTRAINT = p.AXIS.ALL, p.FIXED_CONSTRAINT && (p.DRAG_CONSTRAINT = p.FIXED_CONSTRAINT), p.SHIFT_CONSTRAINT && (p.DRAG_CONSTRAINT = p.SHIFT_CONSTRAINT);
        },
        updateInput: function updateInput(q, r, u) {
          var v = p.mouse,
              A = p.P5.pixelDensity();
          v.prev[0] = v.curr[0], v.prev[1] = v.curr[1], v.prev[2] = v.curr[2], v.curr[0] = q, v.curr[1] = r, v.curr[2] = u, v.dist[0] = -(v.curr[0] - v.prev[0]) / A, v.dist[1] = -(v.curr[1] - v.prev[1]) / A, v.dist[2] = -(v.curr[2] - v.prev[2]) / A;
        },
        mousedown: function mousedown(q) {
          var r = p.mouse;
          0 === q.button && (r.button |= r.BUTTON.LMB), 1 === q.button && (r.button |= r.BUTTON.MMB), 2 === q.button && (r.button |= r.BUTTON.RMB), r.insideViewport(q.x, q.y) && (r.updateInput(q.x, q.y, q.y), r.ismousedown = 0 < r.button, r.isPressed = r.ismousedown, p.SHIFT_CONSTRAINT = 0);
        },
        mousedrag: function mousedrag() {
          var q = p.P5.pixelDensity(),
              r = p.mouse;

          if (r.ismousedown) {
            var u = p.P5.mouseX,
                v = p.P5.mouseY;
            r.updateInput(u, v, v), r.solveConstraint();
            var B = r.button & r.BUTTON.LMB,
                C = r.button & r.BUTTON.MMB,
                D = r.button & r.BUTTON.RMB;
            B && r.mouseDragLeft && r.mouseDragLeft(), C && r.mouseDragCenter && r.mouseDragCenter(), D && r.mouseDragRight && r.mouseDragRight();
          }
        },
        mouseup: function mouseup(q) {
          var r = p.mouse;
          0 === q.button && (r.button &= ~r.BUTTON.LMB), 1 === q.button && (r.button &= ~r.BUTTON.MMB), 2 === q.button && (r.button &= ~r.BUTTON.RMB), r.ismousedown = 0 < r.button, r.isPressed = r.istouchdown || r.ismousedown, p.SHIFT_CONSTRAINT = 0;
        },
        dblclick: function dblclick(q) {
          var r = q.x,
              u = q.y;
          p.mouse.insideViewport(r, u) && p.reset();
        },
        wheel: function wheel(q) {
          var r = q.x,
              u = q.y,
              v = p.mouse;
          v.insideViewport(r, u) && (v.mwheel = 0.01 * q.deltaY, v.mouseWheelAction && v.mouseWheelAction());
        },
        evaluateTouches: function evaluateTouches(q) {
          var B,
              C,
              D,
              r = q.touches,
              u = 0,
              v = 0,
              A = 0,
              E = r.length;

          for (B = 0; B < E; B++) {
            u += r[B].clientX, v += r[B].clientY;
          }

          for (u /= E, v /= E, B = 0; B < E; B++) {
            C = u - r[B].clientX, D = v - r[B].clientY, A += Math.sqrt(C * C + D * D);
          }

          A /= E, p.mouse.updateInput(u, v, -A);
        },
        touchstart: function touchstart(q) {
          q.preventDefault(), q.stopPropagation();
          var r = p.mouse;
          r.evaluateTouches(q), r.istouchdown = r.insideViewport(r.curr[0], r.curr[1]), r.isPressed = p.mouse.istouchdown || p.mouse.ismousedown, r.dbltap(q);
        },
        touchmove: function touchmove(q) {
          q.preventDefault(), q.stopPropagation();
          var r = p.mouse;
          r.istouchdown && (r.evaluateTouches(q), r.solveConstraint(), 1 === q.touches.length ? r.touchmoveSingle() : (r.touchmoveMulti(), r.tapcount = 0));
        },
        touchend: function touchend(q) {
          q.preventDefault(), q.stopPropagation();
          var r = p.mouse;
          r.istouchdown = !1, r.isPressed = r.istouchdown || r.ismousedown, p.SHIFT_CONSTRAINT = 0, 2 <= r.tapcount && (r.insideViewport(r.curr[0], r.curr[1]) && p.reset(), r.tapcount = 0);
        },
        tapcount: 0,
        dbltap: function dbltap() {
          0 == p.mouse.tapcount++ && setTimeout(function () {
            p.mouse.tapcount = 0;
          }, 350);
        },
        shiftKey: !1,
        keydown: function keydown(q) {
          var r = p.mouse;
          r.shiftKey || (r.shiftKey = 16 === q.keyCode);
        },
        keyup: function keyup(q) {
          var r = p.mouse;
          r.shiftKey && (r.shiftKey = 16 !== q.keyCode, !r.shiftKey && (p.SHIFT_CONSTRAINT = 0));
        }
      }, this.attachMouseListeners(), this.auto_update = !0, this.P5.registerMethod("pre", function () {
        p.auto_update && p.update();
      }), this.dampedZoom = new g(function (q) {
        p.zoom(q * p.getZoomMult());
      }), this.dampedPanX = new g(function (q) {
        p.panX(q * p.getPanMult());
      }), this.dampedPanY = new g(function (q) {
        p.panY(q * p.getPanMult());
      }), this.dampedRotX = new g(function (q) {
        p.rotateX(q * p.getRotationMult());
      }), this.dampedRotY = new g(function (q) {
        p.rotateY(q * p.getRotationMult());
      }), this.dampedRotZ = new g(function (q) {
        p.rotateZ(q * p.getRotationMult());
      }), this.timedRot = new j(p.setInterpolatedRotation.bind(p)), this.timedPan = new j(p.setInterpolatedCenter.bind(p)), this.timedzoom = new j(p.setInterpolatedDistance.bind(p));
    }

    _createClass(f, [{
      key: "setCanvas",
      value: function setCanvas(n) {
        n instanceof p5.RendererGL ? (this.renderer = n, this.graphics = n._pInst instanceof p5 ? n : n._pInst, this.P5 = this.graphics._pInst) : (this.graphics = void 0, this.renderer = void 0);
      }
    }, {
      key: "getCanvas",
      value: function getCanvas() {
        return this.renderer;
      }
    }, {
      key: "attachListener",
      value: function attachListener(n, o, p, q) {
        n && n !== p.el && (this.detachListener(p), p.el = n, p.ev = o, p.op = q, p.el.addEventListener(p.ev, p, p.op));
      }
    }, {
      key: "detachListener",
      value: function detachListener(n) {
        n.el && (n.el.removeEventListener(n.ev, n, n.op), n.el = void 0);
      }
    }, {
      key: "attachMouseListeners",
      value: function attachMouseListeners(n) {
        var o = this.cam,
            p = o.mouse;

        if (n = n || o.renderer, n) {
          var q = {
            passive: !1
          },
              r = n.elt;
          o.attachListener(r, "mousedown", p.mousedown, q), o.attachListener(r, "mouseup", p.mouseup, q), o.attachListener(r, "dblclick", p.dblclick, q), o.attachListener(r, "wheel", p.wheel, q), o.attachListener(r, "touchstart", p.touchstart, q), o.attachListener(r, "touchend", p.touchend, q), o.attachListener(r, "touchmove", p.touchmove, q), o.attachListener(window, "keydown", p.keydown, q), o.attachListener(window, "keyup", p.keyup, q);
        }
      }
    }, {
      key: "removeMouseListeners",
      value: function removeMouseListeners() {
        var n = this.cam,
            o = n.mouse;
        n.detachListener(o.mousedown), n.detachListener(o.mouseup), n.detachListener(o.dblclick), n.detachListener(o.wheel), n.detachListener(o.keydown), n.detachListener(o.keyup), n.detachListener(o.touchstart), n.detachListener(o.touchend), n.detachListener(o.touchmove);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        removeMouseListeners();
      }
    }, {
      key: "getAutoUpdate",
      value: function getAutoUpdate() {
        return this.auto_update;
      }
    }, {
      key: "setAutoUpdate",
      value: function setAutoUpdate(n) {
        this.auto_update = n;
      }
    }, {
      key: "update",
      value: function update() {
        var n = this.cam,
            o = n.mouse;
        o.mousedrag();
        var p = !1;
        p |= n.dampedZoom.update(), p |= n.dampedPanX.update(), p |= n.dampedPanY.update(), p |= n.dampedRotX.update(), p |= n.dampedRotY.update(), p |= n.dampedRotZ.update(), p ? (n.timedRot.stop(), n.timedPan.stop(), n.timedzoom.stop()) : (n.timedRot.update(), n.timedPan.update(), n.timedzoom.update()), n.apply();
      }
    }, {
      key: "apply",
      value: function apply(n) {
        var o = this.cam;
        n = n || o.renderer, n && (this.camEYE = this.getPosition(this.camEYE), this.camLAT = this.getCenter(this.camLAT), this.camRUP = this.getUpVector(this.camRUP), n.camera(this.camEYE[0], this.camEYE[1], this.camEYE[2], this.camLAT[0], this.camLAT[1], this.camLAT[2], this.camRUP[0], this.camRUP[1], this.camRUP[2]));
      }
    }, {
      key: "setViewport",
      value: function setViewport(n) {
        this.viewport = n.slice();
      }
    }, {
      key: "getViewport",
      value: function getViewport() {
        return this.viewport;
      }
    }, {
      key: "mouseWheelZoom",
      value: function mouseWheelZoom() {
        var n = this,
            o = n.mouse;
        n.dampedZoom.addForce(o.mwheel * n.scale_zoomwheel);
      }
    }, {
      key: "mouseDragZoom",
      value: function mouseDragZoom() {
        var n = this,
            o = n.mouse;
        n.dampedZoom.addForce(-o.dist[2]);
      }
    }, {
      key: "mouseDragPan",
      value: function mouseDragPan() {
        var n = this,
            o = n.mouse;
        n.dampedPanX.addForce(n.DRAG_CONSTRAINT & n.AXIS.YAW ? o.dist[0] : 0), n.dampedPanY.addForce(n.DRAG_CONSTRAINT & n.AXIS.PITCH ? o.dist[1] : 0);
      }
    }, {
      key: "mouseDragRotate",
      value: function mouseDragRotate() {
        var n = this,
            o = n.mouse,
            p = o.curr[0],
            q = o.curr[1],
            r = o.dist[0],
            u = o.dist[1],
            v = 2 * Math.min(Math.max((p - n.viewport[0]) / n.viewport[2], 0), 1) - 1,
            A = 2 * Math.min(Math.max((q - n.viewport[1]) / n.viewport[3], 0), 1) - 1;
        n.DRAG_CONSTRAINT & n.AXIS.YAW && n.dampedRotY.addForce(+r * (1 - A * A)), n.DRAG_CONSTRAINT & n.AXIS.PITCH && n.dampedRotX.addForce(-u * (1 - v * v)), n.DRAG_CONSTRAINT & n.AXIS.ROLL && (n.dampedRotZ.addForce(-r * A), n.dampedRotZ.addForce(+u * v));
      }
    }, {
      key: "getZoomMult",
      value: function getZoomMult() {
        return this.state.distance * this.scale_zoom;
      }
    }, {
      key: "getPanMult",
      value: function getPanMult() {
        return this.state.distance * this.scale_pan;
      }
    }, {
      key: "getRotationMult",
      value: function getRotationMult() {
        return Math.pow(Math.log10(1 + this.state.distance), 0.5) * this.scale_rotation;
      }
    }, {
      key: "zoom",
      value: function zoom(n) {
        var o = this.cam,
            p = o.state.distance + n;
        p < o.distance_min && (p = o.distance_min, o.dampedZoom.stop()), p > o.distance_max && (p = o.distance_max, o.dampedZoom.stop()), o.state.distance = p;
      }
    }, {
      key: "panX",
      value: function panX(n) {
        var o = this.cam.state;

        if (n) {
          var p = k.applyToVec3(o.rotation, [n, 0, 0]);
          m.add(o.center, p, o.center);
        }
      }
    }, {
      key: "panY",
      value: function panY(n) {
        var o = this.cam.state;

        if (n) {
          var p = k.applyToVec3(o.rotation, [0, n, 0]);
          m.add(o.center, p, o.center);
        }
      }
    }, {
      key: "pan",
      value: function pan(n) {
        this.cam.panX(n), this.cam.panY(n);
      }
    }, {
      key: "rotateX",
      value: function rotateX(n) {
        this.cam.rotate([1, 0, 0], n);
      }
    }, {
      key: "rotateY",
      value: function rotateY(n) {
        this.cam.rotate([0, 1, 0], n);
      }
    }, {
      key: "rotateZ",
      value: function rotateZ(n) {
        this.cam.rotate([0, 0, 1], n);
      }
    }, {
      key: "rotate",
      value: function rotate(n, o) {
        var p = this.cam.state;

        if (o) {
          var q = k.create({
            axis: n,
            angle: o
          });
          k.applyToRotation(p.rotation, q, p.rotation);
        }
      }
    }, {
      key: "setInterpolatedDistance",
      value: function setInterpolatedDistance(n, o, p) {
        this.cam.state.distance = l.mix(n, o, l.smoothstep(p));
      }
    }, {
      key: "setInterpolatedCenter",
      value: function setInterpolatedCenter(n, o, p) {
        this.cam.state.center = m.mix(n, o, l.smoothstep(p));
      }
    }, {
      key: "setInterpolatedRotation",
      value: function setInterpolatedRotation(n, o, p) {
        this.cam.state.rotation = k.slerp(n, o, p);
      }
    }, {
      key: "setDistanceMin",
      value: function setDistanceMin(n) {
        this.distance_min = Math.max(n, this.distance_min_limit), this.zoom(0);
      }
    }, {
      key: "setDistanceMax",
      value: function setDistanceMax(n) {
        this.distance_max = n, this.zoom(0);
      }
    }, {
      key: "setDistance",
      value: function setDistance(n, o) {
        this.timedzoom.start(this.state.distance, n, o, [this.dampedZoom]);
      }
    }, {
      key: "getDistance",
      value: function getDistance() {
        return this.state.distance;
      }
    }, {
      key: "setCenter",
      value: function setCenter(n, o) {
        this.timedPan.start(this.state.center, n, o, [this.dampedPanX, this.dampedPanY]);
      }
    }, {
      key: "getCenter",
      value: function getCenter() {
        return this.state.center;
      }
    }, {
      key: "setRotation",
      value: function setRotation(n, o) {
        this.timedRot.start(this.state.rotation, n, o, [this.dampedRotX, this.dampedRotY, this.dampedRotZ]);
      }
    }, {
      key: "getRotation",
      value: function getRotation() {
        return this.state.rotation;
      }
    }, {
      key: "getPosition",
      value: function getPosition(n) {
        var o = this.cam,
            p = o.state;
        return n = m.assert(n), k.applyToVec3(p.rotation, o.LOOK, n), m.mult(n, p.distance, n), m.add(n, p.center, n), n;
      }
    }, {
      key: "getUpVector",
      value: function getUpVector(n) {
        var o = this.cam,
            p = o.state;
        return n = m.assert(n), k.applyToVec3(p.rotation, o.UP, n), n;
      }
    }, {
      key: "getState",
      value: function getState() {
        return this.state.copy();
      }
    }, {
      key: "setState",
      value: function setState(n, o) {
        n && (this.setDistance(n.distance, o), this.setCenter(n.center, o), this.setRotation(n.rotation, o));
      }
    }, {
      key: "pushState",
      value: function pushState() {
        return this.state_pushed = this.getState();
      }
    }, {
      key: "popState",
      value: function popState(n) {
        this.setState(this.state_pushed, n);
      }
    }, {
      key: "pushResetState",
      value: function pushResetState() {
        return this.state_reset = this.getState();
      }
    }, {
      key: "reset",
      value: function reset(n) {
        this.setState(this.state_reset, n);
      }
    }, {
      key: "setRotationScale",
      value: function setRotationScale(n) {
        this.scale_rotation = n;
      }
    }, {
      key: "setPanScale",
      value: function setPanScale(n) {
        this.scale_pan = n;
      }
    }, {
      key: "setZoomScale",
      value: function setZoomScale(n) {
        this.scale_zoom = n;
      }
    }, {
      key: "setWheelScale",
      value: function setWheelScale(n) {
        this.scale_zoomwheel = n;
      }
    }, {
      key: "getRotationScale",
      value: function getRotationScale() {
        return this.scale_rotation;
      }
    }, {
      key: "getPanScale",
      value: function getPanScale() {
        return this.scale_pan;
      }
    }, {
      key: "getZoomScale",
      value: function getZoomScale() {
        return this.scale_zoom;
      }
    }, {
      key: "getWheelScale",
      value: function getWheelScale() {
        return this.scale_zoomwheel;
      }
    }, {
      key: "setDamping",
      value: function setDamping(n) {
        this.dampedZoom.damping = n, this.dampedPanX.damping = n, this.dampedPanY.damping = n, this.dampedRotX.damping = n, this.dampedRotY.damping = n, this.dampedRotZ.damping = n;
      }
    }, {
      key: "setDefaultInterpolationTime",
      value: function setDefaultInterpolationTime(n) {
        this.timedRot.default_duration = n, this.timedPan.default_duration = n, this.timedzoom.default_duration = n;
      }
    }, {
      key: "setRotationConstraint",
      value: function setRotationConstraint(n, o, p) {
        var q = this.cam;
        q.FIXED_CONSTRAINT = 0, q.FIXED_CONSTRAINT |= n ? q.AXIS.YAW : 0, q.FIXED_CONSTRAINT |= o ? q.AXIS.PITCH : 0, q.FIXED_CONSTRAINT |= p ? q.AXIS.ROLL : 0;
      }
    }, {
      key: "beginHUD",
      value: function beginHUD(n, o, p) {
        var q = this.cam;

        if (n = n || q.renderer, !!n) {
          n.push();
          var r = n.drawingContext,
              o = void 0 === o ? n.width : o,
              p = void 0 === p ? n.height : p,
              u = Number.MAX_VALUE;
          r.flush(), r.disable(r.DEPTH_TEST), this.pushed_uMVMatrix = n.uMVMatrix.copy(), this.pushed_uPMatrix = n.uPMatrix.copy(), n.resetMatrix(), n.ortho(0, o, -p, 0, -u, +u);
        }
      }
    }, {
      key: "endHUD",
      value: function endHUD(n) {
        var o = this.cam;

        if (n = n || o.renderer, !!n) {
          var p = n.drawingContext;
          p.flush(), n.uMVMatrix.set(this.pushed_uMVMatrix), n.uPMatrix.set(this.pushed_uPMatrix), p.enable(p.DEPTH_TEST), n.pop();
        }
      }
    }]);

    return f;
  }();

  var g = /*#__PURE__*/function () {
    function g(n) {
      _classCallCheck(this, g);

      this.value = 0, this.damping = 0.85, this.action = n;
    }

    _createClass(g, [{
      key: "addForce",
      value: function addForce(n) {
        this.value += n;
      }
    }, {
      key: "update",
      value: function update() {
        var n = 1e-6 < this.value * this.value;
        return n ? (this.action(this.value), this.value *= this.damping) : this.stop(), n;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.value = 0;
      }
    }]);

    return g;
  }();

  var j = /*#__PURE__*/function () {
    function j(n) {
      _classCallCheck(this, j);

      this.default_duration = 300, this.action = n;
    }

    _createClass(j, [{
      key: "start",
      value: function start(n, o, p, q) {
        for (var r in q) {
          q[r].stop();
        }

        this.valA = n, this.valB = o, this.duration = void 0 === p ? this.default_duration : p, this.timer = new Date().getTime(), this.active = 0 < this.duration, this.active || this.interpolate(1);
      }
    }, {
      key: "update",
      value: function update() {
        if (this.active) {
          var n = (new Date().getTime() - this.timer) / this.duration;
          0.995 < n ? (this.interpolate(1), this.stop()) : this.interpolate(n);
        }
      }
    }, {
      key: "interpolate",
      value: function interpolate(n) {
        this.action(this.valA, this.valB, n);
      }
    }, {
      key: "stop",
      value: function stop() {
        this.active = !1;
      }
    }]);

    return j;
  }();

  var k = {
    assert: function assert(n) {
      return void 0 === n || n.constructor !== Array ? [1, 0, 0, 0] : n;
    },
    identity: function identity() {
      return [1, 0, 0, 0];
    },
    applyToVec3: function applyToVec3(n, o, p) {
      var _o = _slicedToArray(o, 3),
          q = _o[0],
          r = _o[1],
          u = _o[2],
          _n2 = _slicedToArray(n, 4),
          v = _n2[0],
          A = _n2[1],
          B = _n2[2],
          C = _n2[3],
          D = A * q + B * r + C * u;

      return p = m.assert(p), p[0] = 2 * (v * (q * v - (B * u - C * r)) + D * A) - q, p[1] = 2 * (v * (r * v - (C * q - A * u)) + D * B) - r, p[2] = 2 * (v * (u * v - (A * r - B * q)) + D * C) - u, p;
    },
    applyToRotation: function applyToRotation(n, o, p) {
      var _n3 = _slicedToArray(n, 4),
          q = _n3[0],
          r = _n3[1],
          u = _n3[2],
          v = _n3[3],
          _o2 = _slicedToArray(o, 4),
          A = _o2[0],
          B = _o2[1],
          C = _o2[2],
          D = _o2[3];

      return p = k.assert(p), p[0] = A * q - (B * r + C * u + D * v), p[1] = B * q + A * r + (C * v - D * u), p[2] = C * q + A * u + (D * r - B * v), p[3] = D * q + A * v + (B * u - C * r), p;
    },
    slerp: function slerp(n, o, p, q) {
      var _n4 = _slicedToArray(n, 4),
          r = _n4[0],
          u = _n4[1],
          v = _n4[2],
          A = _n4[3],
          _o3 = _slicedToArray(o, 4),
          B = _o3[0],
          C = _o3[1],
          D = _o3[2],
          E = _o3[3],
          F = r * B + u * C + v * D + A * E;

      0 > F && (B = -B, C = -C, D = -D, E = -E, F = -F);
      var I,
          J,
          G = Math.acos(F),
          H = Math.sqrt(1 - F * F);
      return 1e-3 < H ? (I = Math.sin((1 - p) * G) / H, J = Math.sin(p * G) / H) : (I = 1 - p, J = p), q = k.assert(q), q[0] = I * r + J * B, q[1] = I * u + J * C, q[2] = I * v + J * D, q[3] = I * A + J * E, k.create({
        rotation: q,
        normalize: !0
      }, q);
    },
    create: function create(n, o) {
      if (o = k.assert(o), n.axis) {
        var p = n.axis,
            q = n.angle,
            r = m.mag(p);
        if (0 == r) return;
        var u = -0.5 * q,
            v = Math.sin(u) / r;
        return o[0] = Math.cos(u), o[1] = v * p[0], o[2] = v * p[1], o[3] = v * p[2], o;
      }

      if (n.rotation) {
        if (o[0] = n.rotation[0], o[1] = n.rotation[1], o[2] = n.rotation[2], o[3] = n.rotation[3], n.normalize) {
          var A = 1 / Math.sqrt(o[0] * o[0] + o[1] * o[1] + o[2] * o[2] + o[3] * o[3]);
          o[0] *= A, o[1] *= A, o[2] *= A, o[3] *= A;
        }

        return o;
      }

      if (n.angles_xyz) {
        var B = -0.5 * n.angles_xyz[0],
            C = -0.5 * n.angles_xyz[1],
            D = -0.5 * n.angles_xyz[2],
            E = [Math.cos(B), Math.sin(B), 0, 0],
            F = [Math.cos(C), 0, Math.sin(C), 0],
            G = [Math.cos(D), 0, 0, Math.sin(D)];
        return k.applyToRotation(F, G, o), k.applyToRotation(E, o, o), o;
      }
    }
  },
      l = {
    mix: function mix(n, o, p) {
      return n * (1 - p) + o * p;
    },
    smoothstep: function smoothstep(n) {
      return n * n * (3 - 2 * n);
    },
    smootherstep: function smootherstep() {
      return x * x * x * (x * (6 * x - 15) + 10);
    }
  },
      m = {
    assert: function assert(n) {
      return void 0 === n || n.constructor !== Array ? [0, 0, 0] : n;
    },
    isScalar: function isScalar(n) {
      return void 0 !== n && n.constructor !== Array;
    },
    add: function add(n, o, p) {
      return p = this.assert(p), this.isScalar(o) ? (p[0] = n[0] + o, p[1] = n[1] + o, p[2] = n[2] + o) : (p[0] = n[0] + o[0], p[1] = n[1] + o[1], p[2] = n[2] + o[2]), p;
    },
    mult: function mult(n, o, p) {
      return p = this.assert(p), this.isScalar(o) ? (p[0] = n[0] * o, p[1] = n[1] * o, p[2] = n[2] * o) : (p[0] = n[0] * o[0], p[1] = n[1] * o[1], p[2] = n[2] * o[2]), p;
    },
    magSq: function magSq(n) {
      return n[0] * n[0] + n[1] * n[1] + n[2] * n[2];
    },
    mag: function mag(n) {
      return Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
    },
    dot: function dot(n, o) {
      return n[0] * o[0] + n[1] * o[1] + n[2] * o[2];
    },
    cross: function cross(n, o, p) {
      return p = this.assert(p), p[0] = n[1] * o[2] - n[2] * o[1], p[1] = n[2] * o[0] - n[0] * o[2], p[2] = n[0] * o[1] - n[1] * o[0], p;
    },
    angle: function angle(n, o) {
      var p = this.mag(n) * this.mag(o);
      if (0 == p) return 0;
      var q = this.dot(n, o),
          r = 0.9999 * p;

      if (q < -r || q > r) {
        var u = this.cross(n, o);
        return 0 <= q ? Math.asin(this.mag(u) / p) : Math.PI - Math.asin(this.mag(u) / p);
      }

      return Math.acos(q / p);
    },
    mix: function mix(n, o, p, q) {
      return q = this.assert(q), q[0] = l.mix(n[0], o[0], p), q[1] = l.mix(n[1], o[1], p), q[2] = l.mix(n[2], o[2], p), q;
    }
  };
  return f.INFO = e, Object.freeze(e), c = void 0 === c ? {} : c, c.EasyCam = f, c.DampedAction = g, c.Interpolation = j, c.Rotation = k, c.Vec3 = m, c.Scalar = l, c;
}(Dw);

p5 && (p5.prototype.createEasyCam = function () {
  var c = this._renderer,
      e = arguments[0];
  return arguments[0] instanceof p5.RendererGL && (c = arguments[0], e = arguments[1]), new Dw.EasyCam(c, e);
}, p5.prototype.ortho = function () {
  return this._renderer.ortho.apply(this._renderer, arguments), this;
}, p5.RendererGL.prototype.ortho = function (c, e, f, g, j, k) {
  c === void 0 && (c = -this.width / 2), e === void 0 && (e = +this.width / 2), f === void 0 && (f = -this.height / 2), g === void 0 && (g = +this.height / 2), j === void 0 && (j = 0), k === void 0 && (k = Math.max(this.width, this.height));
  var l = e - c,
      m = g - f,
      n = k - j,
      r = -(e + c) / l,
      u = -(g + f) / m,
      v = -(k + j) / n;
  this.uPMatrix = p5.Matrix.identity(), this.uPMatrix.set(2 / l, 0, 0, 0, 0, -(2 / m), 0, 0, 0, 0, -2 / n, 0, r, u, v, 1), this._curCamera = "custom";
});